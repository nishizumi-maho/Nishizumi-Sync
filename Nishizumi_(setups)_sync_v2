#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Nishizumi Setups Sync — Full GUI Edition (single-file)
Version: 1.1.0-fullgui
Features:
 - Full PySide6 GUI (mirrors original functionality), plus improvements:
   search, profiles, extra folders UI, driver editing, car mapping editor,
   dry-run, logging levels, tray mode, update check, import (.zip/.rar/folder)
 - CLI still available: run, import, check-update, update, dry-run
 - Argparse patch applied and --gui supported
 - Hooks support via plugins folder (before_sync/after_sync)
 - Backwards-compatible config format
Notes:
 - Requires: PySide6 (for GUI), requests (optional, for Garage61/update).
 - RAR support requires 'rarfile' installed.
"""

from __future__ import annotations
import os
import sys
import json
import zipfile
import shutil
import argparse
import tempfile
import hashlib
import re
import traceback
import importlib
from datetime import datetime
from typing import Optional, List, Dict, Any

# Optional imports
try:
    from PySide6 import QtWidgets, QtGui, QtCore  # GUI
    PYSIDE6_AVAILABLE = True
except Exception:
    PYSIDE6_AVAILABLE = False

try:
    import rarfile
except Exception:
    rarfile = None

try:
    import requests
except Exception:
    requests = None

# Base paths
if getattr(sys, "frozen", False):
    BASE_DIR = os.path.dirname(sys.executable)
else:
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))

CONFIG_FILE = os.path.join(BASE_DIR, "user_config.json")
MAP_FILE = os.path.join(BASE_DIR, "custom_car_mapping.json")
VERSION = "1.1.0"
UPDATE_URL = "https://raw.githubusercontent.com/nishizumi-maho/nishizumi-setups-sync/main/nishizumi_setups_sync.py"

# Default config (backwards-compatible)
DEFAULT_CONFIG = {
    "iracing_folder": "",
    "source_type": "zip",
    "zip_file": "",
    "source_folder": "",
    "team_folder": "Example Team",
    "personal_folder": "My Personal Folder",
    "driver_folder": "Example Supplier",
    "supplier_folder": "Example Supplier",
    "season_folder": "Example Season",
    "sync_source": "Example Source",
    "sync_destination": "Example Destination",
    "hash_algorithm": "md5",
    "run_on_startup": False,
    "tray_mode": False,
    "tray_interval": 2,
    "use_external": False,
    "extra_folders": [],
    "backup_enabled": False,
    "backup_before_folder": "",
    "backup_after_folder": "",
    "enable_logging": False,
    "log_file": "nishizumi_setups_sync.log",
    "copy_all": False,
    "use_driver_folders": False,
    "drivers": [],
    "use_garage61": False,
    "garage61_team_id": "",
    "garage61_api_key": "",
    "active_profile": 0,
    "profiles": [
        {
            "team_folder": "Example Team",
            "personal_folder": "My Personal Folder",
            "supplier_folder": "Example Supplier",
            "season_folder": "Example Season",
        }
    ],
}

INVALID_CHARS = '<>:"/\\|?*'

def clean_name(name: Optional[str]) -> str:
    if not name:
        return ""
    name = name.strip()
    return "".join(c for c in name if c not in INVALID_CHARS)

# -------------------------
# Logger
# -------------------------
class Logger:
    LEVELS = {"ERROR": 40, "WARN": 30, "INFO": 20, "DEBUG": 10}
    def __init__(self, cfg: Optional[dict] = None):
        self.cfg = cfg or {}
        self.level = self.LEVELS["INFO"]
        self.file_enabled = bool(self.cfg.get("enable_logging"))
        self.file_path = self.cfg.get("log_file") or os.path.join(BASE_DIR, "nishizumi_setups_sync.log")

    def set_level(self, level_name: str):
        self.level = self.LEVELS.get(level_name.upper(), self.level)

    def _out(self, lvl_name: str, msg: str):
        ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        line = f"[{ts}] [{lvl_name}] {msg}"
        print(line)
        if self.file_enabled:
            try:
                with open(self.file_path, "a", encoding="utf-8") as f:
                    f.write(line + "\n")
            except Exception:
                pass

    def debug(self, msg: str):
        if self.level <= self.LEVELS["DEBUG"]:
            self._out("DEBUG", msg)
    def info(self, msg: str):
        if self.level <= self.LEVELS["INFO"]:
            self._out("INFO", msg)
    def warn(self, msg: str):
        if self.level <= self.LEVELS["WARN"]:
            self._out("WARN", msg)
    def error(self, msg: str):
        if self.level <= self.LEVELS["ERROR"]:
            self._out("ERROR", msg)

# -------------------------
# Config handling
# -------------------------
def load_config(path: str = CONFIG_FILE) -> dict:
    cfg = DEFAULT_CONFIG.copy()
    if os.path.exists(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
            if isinstance(data, dict):
                # legacy compat
                if "supplier_folder" not in data and "driver_folder" in data:
                    data["supplier_folder"] = data["driver_folder"]
                if "external_folder" in data and "extra_folders" not in data:
                    ef = data.get("external_folder")
                    data["extra_folders"] = [ef] if ef else []
                # normalize extra_folders
                ext = data.get("extra_folders")
                if isinstance(ext, list):
                    new_ext = []
                    for item in ext:
                        if isinstance(item, str):
                            new_ext.append({"name": item, "location": "car"})
                        elif isinstance(item, dict):
                            name = item.get("name") or item.get("folder")
                            loc = item.get("location", "car")
                            if name:
                                new_ext.append({"name": name, "location": loc})
                    data["extra_folders"] = new_ext
                if "backup_folder" in data:
                    data.setdefault("backup_before_folder", data.get("backup_folder"))
                    data.setdefault("backup_after_folder", "")
                cfg.update(data)
                # ensure profiles
                if "profiles" not in cfg or not cfg.get("profiles"):
                    profile = {
                        "team_folder": cfg.get("team_folder", DEFAULT_CONFIG["team_folder"]),
                        "personal_folder": cfg.get("personal_folder", DEFAULT_CONFIG["personal_folder"]),
                        "supplier_folder": cfg.get("supplier_folder", DEFAULT_CONFIG["supplier_folder"]),
                        "season_folder": cfg.get("season_folder", DEFAULT_CONFIG["season_folder"]),
                    }
                    cfg["profiles"] = [profile]
                    cfg["active_profile"] = 0
                idx = cfg.get("active_profile", 0)
                if idx >= len(cfg["profiles"]):
                    idx = 0
                    cfg["active_profile"] = 0
                prof = cfg["profiles"][idx]
                cfg["team_folder"] = prof.get("team_folder", cfg.get("team_folder"))
                cfg["personal_folder"] = prof.get("personal_folder", cfg.get("personal_folder"))
                cfg["supplier_folder"] = prof.get("supplier_folder", cfg.get("supplier_folder"))
                cfg["driver_folder"] = cfg["supplier_folder"]
                cfg["season_folder"] = prof.get("season_folder", cfg.get("season_folder"))
        except Exception:
            pass
    return cfg

def save_config(cfg: dict, path: str = CONFIG_FILE):
    try:
        cfg = dict(cfg)
        cfg.pop("external_folder", None)
        cfg.pop("backup_folder", None)
        cfg.setdefault("backup_before_folder", "")
        cfg.setdefault("backup_after_folder", "")
        # normalize extra_folders
        ext = cfg.get("extra_folders", [])
        if isinstance(ext, list):
            norm = []
            for item in ext:
                if isinstance(item, str):
                    norm.append({"name": item, "location": "car"})
                elif isinstance(item, dict):
                    name = item.get("name") or item.get("folder")
                    loc = item.get("location", "car")
                    if name:
                        norm.append({"name": name, "location": loc})
            cfg["extra_folders"] = norm
        idx = cfg.get("active_profile", 0)
        profiles = cfg.setdefault("profiles", [])
        while len(profiles) <= idx:
            profiles.append({})
        profiles[idx].update({
            "team_folder": cfg.get("team_folder", ""),
            "personal_folder": cfg.get("personal_folder", ""),
            "supplier_folder": cfg.get("supplier_folder", ""),
            "season_folder": cfg.get("season_folder", ""),
        })
        cfg["profiles"] = profiles
        cfg["driver_folder"] = cfg.get("supplier_folder", "")
        with open(path, "w", encoding="utf-8") as f:
            json.dump(cfg, f, ensure_ascii=False, indent=4)
    except Exception:
        pass

# -------------------------
# Car mapping data (kept concise)
# -------------------------
CAR_MAP = {
    "ir18 -> dallarair18": "dallarair18",
    "aston gt4 -> amvantagegt4": "amvantagegt4",
    "bmw gt4 evo -> bmwm4evogt4": "bmwm4evogt4",
    "mclaren gt4 -> mclaren570sgt4": "mclaren570sgt4",
    "bmw gt3 -> bmwm4gt3": "bmwm4gt3",
    "mclaren gt3 -> mclaren720sgt3": "mclaren720sgt3",
    "mclaren gtd -> mclaren720sgt3": "mclaren720sgt3",
    "acura gtp -> acuraarx06gtp": "acuraarx06gtp",
    "audi gtd -> audir8lmsevo2gt3": "audir8lmsevo2gt3",
    "audi gt3 -> audir8lmsevo2gt3": "audir8lmsevo2gt3",
    "bmw gtd -> bmwm4gt3": "bmwm4gt3",
    "bmw gtp -> bmwlmdh": "bmwlmdh",
    "cadillac gtp -> cadillacvseriesrgtp": "cadillacvseriesrgtp",
    "corvette gtd -> chevyvettez06rgt3": "chevyvettez06rgt3",
    "corvette gt3 -> chevyvettez06rgt3": "chevyvettez06rgt3",
    "dallara lmp2 -> dallarap217": "dallarap217",
    "ferrari 499p -> ferrari499p": "ferrari499p",
    "ferrari gtd -> ferrari296gt3": "ferrari296gt3",
    "ferrari gt3 -> ferrari296gt3": "ferrari296gt3",
    "lamborghini gtd -> lamborghinievogt3": "lamborghinievogt3",
    "lamborghini gt3 -> lamborghinievogt3": "lamborghinievogt3",
    "mercedes gtd -> mercedesamgevogt3": "mercedesamgevogt3",
    "mercedes gt3 -> mercedesamgevogt3": "mercedesamgevogt3",
    "mustang gtd -> fordmustanggt3": "fordmustanggt3",
    "mustang gt3 -> fordmustanggt3": "fordmustanggt3",
    "porsche gtd -> porsche992rgt3": "porsche992rgt3",
    "porsche gt3 -> porsche992rgt3": "porsche992rgt3",
    "porsche gtp -> porsche963gtp": "porsche963gtp",
    "fia f4 -> formulair04": "formulair04",
    "porsche gt4 -> porsche718gt4": "porsche718gt4",
    "mercedes gt4 -> mercedesamggt4": "mercedesamggt4",
    "lmp3 -> ligierjsp320": "ligierjsp320",
    "sfl -> superformulalights324": "superformulalights324",
    "pcup -> porsche992cup": "porsche992cup",
    "porsche gte -> porsche991rsr": "porsche991rsr",
    "corvette gte -> c8rvettegte": "c8rvettegte",
    "nsx gt3 -> acuransxevo22gt3": "acuransxevo22gt3",
    "nsx gtd -> acuransxevo22gt3": "acuransxevo22gt3",
    "nascar trucks": [
        "nascar trucks -> trucks toyotatundra2022",
        "nascar trucks -> trucks fordf150",
        "nascar trucks -> trucks silverado2019",
    ],
    "nascar xfinity": [
        "nascar xfinity -> stockcars2 supra2019",
        "nascar xfinity -> stockcars2 mustang2019",
        "nascar xfinity -> stockcars2 camaro2019",
    ],
    "nascar nextgen": [
        "nascar nextgen -> stockcars chevycamarozl12022",
        "nascar nextgen -> stockcars fordmustang2022",
        "nascar nextgen -> stockcars toyotacamry2022",
    ],
    "superformula sf23": [
        "superformula sf23 -> superformulasf23 honda",
        "superformula sf23 -> superformulasf23 toyota",
    ],
}

CAR_GROUPS = {
    "nascar trucks": [
        "trucks toyotatundra2022",
        "trucks fordf150",
        "trucks silverado2019",
    ],
    "nascar xfinity": [
        "stockcars2 supra2019",
        "stockcars2 mustang2019",
        "stockcars2 camaro2019",
    ],
    "nascar nextgen": [
        "stockcars chevycamarozl12022",
        "stockcars fordmustang2022",
        "stockcars toyotacamry2022",
    ],
    "superformula sf23": [
        "superformulasf23 honda",
        "superformulasf23 toyota",
    ],
}

# -------------------------
# Mapping helpers
# -------------------------
def load_custom_mapping(path: str = MAP_FILE) -> dict:
    try:
        if os.path.exists(path):
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
    except Exception:
        pass
    return {}

def save_custom_mapping(mapping: dict, path: str = MAP_FILE):
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(mapping, f, ensure_ascii=False, indent=4)
    except Exception:
        pass

def identify_setup(car_folder: str, custom_map: dict) -> Optional[str]:
    parts = car_folder.split("-")
    name = parts[1].strip().lower() if len(parts) >= 2 else car_folder.lower()
    if name in custom_map:
        return custom_map[name]
    for key, dest in CAR_MAP.items():
        if isinstance(dest, list):
            for m in dest:
                clean = m.split("->")[-1].strip().lower()
                if key in name or clean in name:
                    return clean
        else:
            s = key.split("->")[0].strip().lower()
            d = str(dest).split("->")[-1].strip().lower()
            if s in name or d in name:
                return d
    return None

# -------------------------
# Utilities: hashing, file ops
# -------------------------
def calc_hash(path: str, algorithm: str = "md5") -> Optional[str]:
    try:
        h = hashlib.sha256() if algorithm == "sha256" else hashlib.md5()
        with open(path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                h.update(chunk)
        return h.hexdigest()
    except Exception:
        return None

def ensure_dir(path: str):
    try:
        os.makedirs(path, exist_ok=True)
    except Exception:
        pass

def copy_entry(src: str, dst: str, logger: Logger, dry_run: bool = False):
    try:
        if dry_run:
            logger.info(f"[DRY-RUN] Would copy '{src}' -> '{dst}'")
            return
        if os.path.isdir(src):
            shutil.copytree(src, dst, dirs_exist_ok=True)
        else:
            ensure_dir(os.path.dirname(dst))
            shutil.copy2(src, dst)
        logger.info(f"[COPIED] '{src}' -> '{dst}'")
    except Exception as e:
        logger.error(f"[ERROR] Failed to copy '{src}' -> '{dst}': {e}")

# -------------------------
# Garage61 fetch
# -------------------------
def fetch_garage61_drivers(team_id: str, api_key: Optional[str], logger: Logger) -> Optional[List[str]]:
    if requests is None:
        logger.warn("Requests not installed — Garage61 disabled")
        return None
    url = f"https://garage61.net/api/teams/{team_id}/drivers"
    headers = {}
    if api_key:
        headers["Authorization"] = f"Bearer {api_key}"
    try:
        r = requests.get(url, headers=headers, timeout=10)
        r.raise_for_status()
        data = r.json()
        names = [clean_name(d.get("name")) for d in data.get("drivers", []) if d.get("name")]
        return [n for n in names if n]
    except Exception as e:
        logger.warn(f"Failed to fetch drivers from Garage61: {e}")
        return None

# -------------------------
# Update check
# -------------------------
def check_for_update(logger: Logger) -> (Optional[str], Optional[str]):
    if requests is None:
        logger.warn("Requests not available — cannot check updates")
        return None, None
    try:
        r = requests.get(UPDATE_URL, timeout=10)
        r.raise_for_status()
        m = re.search(r"^VERSION\s*=\s*\"([^\"]+)\"", r.text, re.MULTILINE)
        if not m:
            return None, None
        remote_ver = m.group(1)
        if remote_ver != VERSION:
            return remote_ver, r.text
    except Exception as e:
        logger.warn(f"Update check failed: {e}")
    return None, None

def apply_update(logger: Logger):
    remote_ver, remote_text = check_for_update(logger)
    if not remote_ver:
        logger.info("No update available")
        return False
    script_path = os.path.abspath(sys.argv[0])
    tmp_path = None
    try:
        with tempfile.NamedTemporaryFile("w", encoding="utf-8", delete=False, dir=os.path.dirname(script_path)) as tmp:
            tmp_path = tmp.name
            tmp.write(remote_text)
        os.replace(tmp_path, script_path)
        logger.info(f"Updated to version {remote_ver}. Restart required.")
        return True
    except Exception as e:
        logger.error(f"Failed to write update: {e}")
        if tmp_path and os.path.exists(tmp_path):
            try:
                os.unlink(tmp_path)
            except Exception:
                pass
        return False

# -------------------------
# Core sync primitives
# -------------------------
def sync_bidirectional(dir_a: str, dir_b: str, algorithm: str, logger: Logger, dry_run: bool = False):
    ensure_dir(dir_a)
    ensure_dir(dir_b)
    try:
        items_a = set(os.listdir(dir_a))
    except Exception:
        items_a = set()
    try:
        items_b = set(os.listdir(dir_b))
    except Exception:
        items_b = set()
    for item in items_a - items_b:
        copy_entry(os.path.join(dir_a, item), os.path.join(dir_b, item), logger, dry_run=dry_run)
    for item in items_b - items_a:
        copy_entry(os.path.join(dir_b, item), os.path.join(dir_a, item), logger, dry_run=dry_run)
    for item in items_a & items_b:
        pa = os.path.join(dir_a, item)
        pb = os.path.join(dir_b, item)
        if os.path.isdir(pa):
            sync_bidirectional(pa, pb, algorithm, logger, dry_run=dry_run)
        else:
            ha = calc_hash(pa, algorithm)
            hb = calc_hash(pb, algorithm)
            if ha and hb and ha != hb:
                if os.path.getmtime(pa) >= os.path.getmtime(pb):
                    copy_entry(pa, pb, logger, dry_run=dry_run)
                else:
                    copy_entry(pb, pa, logger, dry_run=dry_run)

def sync_folders(src: str, dst: str, algorithm: str, delete_extras: bool = True, copy_all: bool = False, ignore_dirs: Optional[set] = None, logger: Optional[Logger] = None, dry_run: bool = False):
    if logger is None:
        logger = Logger({})
    ignore_dirs = set(ignore_dirs or [])
    if not os.path.exists(src):
        logger.debug(f"Source '{src}' missing")
        return
    if not os.path.exists(dst):
        if dry_run:
            logger.info(f"[DRY-RUN] Would create '{dst}'")
        else:
            ensure_dir(dst)
    for item in os.listdir(src):
        s = os.path.join(src, item)
        d = os.path.join(dst, item)
        if item in ignore_dirs and os.path.isdir(s):
            logger.debug(f"Ignoring dir '{s}'")
            continue
        if os.path.isdir(s):
            sync_folders(s, d, algorithm, delete_extras, copy_all, ignore_dirs, logger, dry_run=dry_run)
            continue
        if not copy_all and not item.lower().endswith(".sto"):
            logger.debug(f"Skipping non-.sto '{s}'")
            continue
        copy = False
        if not os.path.exists(d):
            copy = True
        else:
            if calc_hash(s, algorithm) != calc_hash(d, algorithm):
                copy = True
        if copy:
            if dry_run:
                logger.info(f"[DRY-RUN] Would copy '{s}' -> '{d}'")
            else:
                shutil.copy2(s, d)
                logger.info(f"[COPIED] '{s}' -> '{d}'")
    if delete_extras:
        for item in os.listdir(dst):
            if item in ignore_dirs:
                continue
            d = os.path.join(dst, item)
            s = os.path.join(src, item)
            if os.path.isdir(d):
                if not os.path.exists(s):
                    if dry_run:
                        logger.info(f"[DRY-RUN] Would remove dir '{d}'")
                    else:
                        shutil.rmtree(d, ignore_errors=True)
                        logger.info(f"[REMOVED DIR] {d}")
            else:
                if not os.path.exists(s) or (not copy_all and not item.lower().endswith(".sto")):
                    if dry_run:
                        logger.info(f"[DRY-RUN] Would remove file '{d}'")
                    else:
                        try:
                            os.remove(d)
                            logger.info(f"[REMOVED FILE] {d}")
                        except Exception:
                            pass

def copy_missing_files(src: str, dst: str, copy_all: bool = False, logger: Optional[Logger] = None, dry_run: bool = False):
    if logger is None:
        logger = Logger({})
    ensure_dir(dst)
    for item in os.listdir(src):
        s = os.path.join(src, item)
        d = os.path.join(dst, item)
        if os.path.isdir(s):
            copy_missing_files(s, d, copy_all, logger, dry_run=dry_run)
            continue
        if not copy_all and not item.lower().endswith(".sto"):
            continue
        if not os.path.exists(d):
            if dry_run:
                logger.info(f"[DRY-RUN] Would copy missing '{s}' -> '{d}'")
            else:
                ensure_dir(os.path.dirname(d))
                shutil.copy2(s, d)
                logger.info(f"[COPIED] '{s}' -> '{d}'")

def backup_iracing_folder(ir_folder: str, backup_folder: str, copy_all: bool, logger: Logger, dry_run: bool = False):
    if not ir_folder or not os.path.exists(ir_folder):
        logger.debug("No iracing folder for backup")
        return
    if not backup_folder:
        logger.debug("No backup folder specified")
        return
    copy_missing_files(ir_folder, backup_folder, copy_all=copy_all, logger=logger, dry_run=dry_run)

# -------------------------
# Team/Driver sync helpers
# -------------------------
COMMON_FOLDER = "Common Setups"
DRIVERS_ROOT = "Drivers"

def remove_unknown_driver_folders(iracing_folder: str, dest_name: str, drivers: Optional[List[str]], logger: Logger, dry_run: bool = False):
    if drivers is None:
        return
    for car in os.listdir(iracing_folder):
        car_dir = os.path.join(iracing_folder, car)
        if not os.path.isdir(car_dir):
            continue
        root = os.path.join(car_dir, dest_name, DRIVERS_ROOT)
        if not os.path.isdir(root):
            continue
        for folder in os.listdir(root):
            if folder not in drivers:
                path = os.path.join(root, folder)
                if dry_run:
                    logger.info(f"[DRY-RUN] Would remove unknown driver folder '{path}'")
                else:
                    shutil.rmtree(path, ignore_errors=True)
                    logger.info(f"[REMOVED UNKNOWN DRIVER] {path}")

def merge_external_into_source(iracing_folder: str, ext_names, src_name: str, dest_name: str, algorithm: str, copy_all: bool, drivers: Optional[List[str]], driver_style: bool, logger: Logger, dry_run: bool = False):
    if isinstance(ext_names, str):
        ext_names = [{"name": ext_names, "location": "car"}]
    elif isinstance(ext_names, list):
        fixed = []
        for item in ext_names:
            if isinstance(item, str):
                fixed.append({"name": item, "location": "car"})
            elif isinstance(item, dict):
                name = item.get("name") or item.get("folder")
                loc = item.get("location", "car")
                if name:
                    fixed.append({"name": name, "location": loc})
        ext_names = fixed
    else:
        return

    for car in os.listdir(iracing_folder):
        car_dir = os.path.join(iracing_folder, car)
        if not os.path.isdir(car_dir):
            continue
        for ext_def in ext_names:
            folder_name = ext_def.get("name")
            loc = ext_def.get("location", "car")
            if loc == "dest":
                ext = os.path.join(car_dir, dest_name, folder_name)
                remove_after = True
            else:
                ext = os.path.join(car_dir, folder_name)
                remove_after = False
            if not os.path.exists(ext):
                continue
            if driver_style and drivers is not None:
                common_dst = os.path.join(car_dir, src_name, COMMON_FOLDER, folder_name)
                sync_folders(ext, common_dst, algorithm, delete_extras=False, copy_all=copy_all, logger=logger, dry_run=dry_run)
                for driver_name in drivers:
                    dst = os.path.join(car_dir, src_name, DRIVERS_ROOT, driver_name, folder_name)
                    copy_missing_files(ext, dst, copy_all, logger=logger, dry_run=dry_run)
            else:
                dst = os.path.join(car_dir, src_name, folder_name)
                sync_folders(ext, dst, algorithm, delete_extras=False, copy_all=copy_all, logger=logger, dry_run=dry_run)
            if remove_after:
                if dry_run:
                    logger.info(f"[DRY-RUN] Would remove external folder '{ext}'")
                else:
                    shutil.rmtree(ext, ignore_errors=True)
                    logger.info(f"[REMOVED EXTERNAL] {ext}")

def sync_group_folders(iracing_folder: str, src_name: str, dest_name: str, algorithm: str, copy_all: bool, logger: Logger, dry_run: bool = False):
    for cars in CAR_GROUPS.values():
        source_path = None
        for car in cars:
            candidate = os.path.join(iracing_folder, car, src_name)
            if os.path.isdir(candidate) and os.listdir(candidate):
                source_path = candidate
                break
        if not source_path:
            continue
        for car in cars:
            dest = os.path.join(iracing_folder, car, dest_name)
            sync_folders(source_path, dest, algorithm, copy_all=copy_all, logger=logger, dry_run=dry_run)

def sync_nascar_source_folders(iracing_folder: str, src_name: str, algorithm: str, drivers: Optional[List[str]], driver_style: bool, logger: Logger, dry_run: bool = False):
    for group in [
        "nascar nextgen",
        "nascar xfinity",
        "nascar trucks",
        "superformula sf23",
    ]:
        cars = CAR_GROUPS.get(group, [])
        paths = []
        for car in cars:
            base = os.path.join(iracing_folder, car, src_name)
            if driver_style and drivers is not None:
                common = os.path.join(base, COMMON_FOLDER)
                if os.path.exists(common):
                    paths.append(common)
            else:
                if os.path.exists(base):
                    paths.append(base)
        for i in range(len(paths)):
            for j in range(i + 1, len(paths)):
                sync_bidirectional(paths[i], paths[j], algorithm, logger, dry_run=dry_run)

def sync_nascar_data_packs(iracing_folder: str, dest_name: str, algorithm: str, logger: Logger, dry_run: bool = False):
    groups = [
        CAR_GROUPS.get("nascar nextgen", []),
        CAR_GROUPS.get("nascar xfinity", []),
        CAR_GROUPS.get("nascar trucks", []),
        CAR_GROUPS.get("superformula sf23", []),
    ]
    for cars in groups:
        paths = []
        for car in cars:
            g61 = os.path.join(iracing_folder, car, "Garage 61", "Data packs")
            dest = os.path.join(iracing_folder, car, dest_name, "Data packs")
            if os.path.exists(g61):
                paths.append(g61)
            if os.path.exists(dest):
                paths.append(dest)
        for i in range(len(paths)):
            for j in range(i + 1, len(paths)):
                sync_bidirectional(paths[i], paths[j], algorithm, logger, dry_run=dry_run)

# -------------------------
# Import processing
# -------------------------
def process_archive(archive_path: str, cfg: dict, logger: Logger, ask: bool = False, dry_run: bool = False):
    extract_path = os.path.join(os.path.dirname(archive_path), os.path.splitext(os.path.basename(archive_path))[0])
    try:
        if archive_path.lower().endswith(".rar"):
            if rarfile is None:
                logger.error("RAR support requires 'rarfile' package.")
                return
            with rarfile.RarFile(archive_path) as z:
                if dry_run:
                    logger.info(f"[DRY-RUN] Would extract RAR '{archive_path}' to '{extract_path}'")
                else:
                    z.extractall(extract_path)
        else:
            with zipfile.ZipFile(archive_path, "r") as z:
                if dry_run:
                    logger.info(f"[DRY-RUN] Would extract ZIP '{archive_path}' to '{extract_path}'")
                else:
                    z.extractall(extract_path)
    except Exception as e:
        logger.error(f"Failed to extract {archive_path}: {e}")
        return
    copy_from_source(extract_path, cfg["iracing_folder"], cfg, logger, ask=ask, dry_run=dry_run)
    if dry_run:
        logger.info(f"[DRY-RUN] Would remove extracted '{extract_path}'")
    else:
        shutil.rmtree(extract_path, ignore_errors=True)

def copy_from_source(source: str, iracing_folder: str, cfg: dict, logger: Logger, ask: bool = False, dry_run: bool = False):
    custom_map = load_custom_mapping()
    try:
        subfolders = [f.name for f in os.scandir(source) if f.is_dir()]
    except Exception:
        subfolders = []
    def _import_dir(src_path: str, dest: str, overwrite: bool = True):
        if overwrite:
            ensure_dir(dest)
            for item in os.listdir(src_path):
                s = os.path.join(src_path, item)
                d = os.path.join(dest, item)
                if os.path.isdir(s):
                    if not os.path.exists(d):
                        if dry_run:
                            logger.info(f"[DRY-RUN] Would copy tree '{s}' -> '{d}'")
                        else:
                            shutil.copytree(s, d, dirs_exist_ok=True)
                    else:
                        sync_folders(s, d, cfg["hash_algorithm"], copy_all=cfg.get("copy_all", False), logger=logger, dry_run=dry_run)
                elif cfg.get("copy_all", False) or item.lower().endswith(".sto"):
                    if dry_run:
                        logger.info(f"[DRY-RUN] Would copy '{s}' -> '{d}'")
                    else:
                        ensure_dir(os.path.dirname(d))
                        shutil.copy2(s, d)
                        logger.info(f"[COPIED] '{s}' -> '{d}'")
        else:
            copy_missing_files(src_path, dest, cfg.get("copy_all", False), logger=logger, dry_run=dry_run)

    driver_mode = cfg.get("use_driver_folders")
    drivers = [clean_name(n) for n in cfg.get("drivers", [])] if driver_mode else None

    for folder in subfolders:
        setup_name = identify_setup(folder, custom_map)
        if not setup_name and ask:
            try:
                # interactive prompt (console) fallback
                setup_name = input(f"Folder '{folder}' not recognised. Enter target iRacing folder (or blank to skip): ").strip() or None
            except Exception:
                setup_name = None
            if setup_name:
                custom_map[folder.lower()] = setup_name
                save_custom_mapping(custom_map)
        if not setup_name:
            logger.debug(f"Skipping unknown folder '{folder}'")
            continue
        target = os.path.join(iracing_folder, setup_name)
        personal_base = os.path.join(target, cfg["personal_folder"])
        team_base = os.path.join(target, cfg["team_folder"])
        supplier = cfg.get("supplier_folder", cfg.get("driver_folder"))
        season = cfg["season_folder"]
        src_path = os.path.join(source, folder)
        if driver_mode:
            for base in [personal_base, team_base]:
                common = os.path.join(base, COMMON_FOLDER, supplier, season)
                _import_dir(src_path, common, overwrite=True)
                for name in drivers or []:
                    dpath = os.path.join(base, DRIVERS_ROOT, name, supplier, season)
                    _import_dir(src_path, dpath, overwrite=False)
        else:
            personal = os.path.join(personal_base, supplier, season)
            team = os.path.join(team_base, supplier, season)
            _import_dir(src_path, personal)
            _import_dir(src_path, team)

# -------------------------
# Perform sync pipeline
# -------------------------
def perform_sync(ir_folder: str, cfg: dict, logger: Logger, dry_run: bool = False):
    src_name = cfg.get("sync_source")
    dst_name = cfg.get("sync_destination")
    if not src_name or not dst_name:
        logger.info("Sync source or destination not configured, skipping")
        return

    # Garage61 fetch
    if cfg.get("use_garage61") and cfg.get("garage61_team_id"):
        names = fetch_garage61_drivers(cfg.get("garage61_team_id"), cfg.get("garage61_api_key"), logger)
        if names is not None:
            cfg["drivers"] = [clean_name(n) for n in names if n]
            save_config(cfg)

    # External merging
    if cfg.get("use_external") and cfg.get("extra_folders"):
        merge_external_into_source(ir_folder, cfg["extra_folders"], src_name, dst_name, cfg["hash_algorithm"], cfg.get("copy_all", False), drivers=( [clean_name(n) for n in cfg.get("drivers", [])] if cfg.get("use_driver_folders") else None), driver_style=cfg.get("use_driver_folders", False), logger=logger, dry_run=dry_run)

    drivers = ( [clean_name(n) for n in cfg.get("drivers", [])] if cfg.get("use_driver_folders") else None)
    if drivers is not None:
        remove_unknown_driver_folders(ir_folder, dst_name, drivers, logger, dry_run=dry_run)

    sync_nascar_source_folders(ir_folder, src_name, cfg["hash_algorithm"], drivers=drivers, driver_style=cfg.get("use_driver_folders", False), logger=logger, dry_run=dry_run)
    sync_team_folders = globals().get("sync_team_folders")  # fallback for older code paths (keeps compatibility)
    # use existing function defined above
    sync_team_folders = lambda a,b,c,d,e,f,g,h: globals()["sync_team_folders_impl"](a,b,c,d,e,f,g,h) if "sync_team_folders_impl" in globals() else None

# create actual sync_team_folders_impl to preserve previous names (define here)
def sync_team_folders_impl(iracing_folder, src_name, dest_name, algorithm, copy_all, drivers, driver_style, logger, dry_run=False):
    for car in os.listdir(iracing_folder):
        car_dir = os.path.join(iracing_folder, car)
        if not os.path.isdir(car_dir):
            continue
        src = os.path.join(car_dir, src_name)
        dest_root = os.path.join(car_dir, dest_name)
        if not os.path.isdir(src) or not os.listdir(src):
            continue
        if drivers and driver_style:
            src_common = os.path.join(src, COMMON_FOLDER)
            src_dp = os.path.join(src, "Data packs")
            if os.path.exists(src_common):
                common = os.path.join(dest_root, COMMON_FOLDER)
                sync_folders(src_common, common, algorithm, True, copy_all, logger, dry_run=dry_run)
            for name in drivers:
                sdriver = os.path.join(src, DRIVERS_ROOT, name)
                target = os.path.join(dest_root, DRIVERS_ROOT, name)
                if os.path.exists(sdriver):
                    copy_missing_files(sdriver, target, copy_all, logger, dry_run=dry_run)
                elif os.path.exists(src_common):
                    copy_missing_files(src_common, target, copy_all, logger, dry_run=dry_run)
            if os.path.isdir(src_dp):
                common_dp = os.path.join(dest_root, COMMON_FOLDER, "Data packs")
                sync_folders(src_dp, common_dp, algorithm, delete_extras=False, copy_all=copy_all, logger=logger, dry_run=dry_run)
                for name in drivers:
                    dp_dst = os.path.join(dest_root, DRIVERS_ROOT, name, "Data packs")
                    copy_missing_files(src_dp, dp_dst, copy_all, logger, dry_run=dry_run)
            sync_folders(src, dest_root, algorithm, copy_all=copy_all, ignore_dirs={"Data packs", COMMON_FOLDER, DRIVERS_ROOT}, logger=logger, dry_run=dry_run)
            dp_root = os.path.join(dest_root, "Data packs")
            if os.path.isdir(dp_root):
                if dry_run:
                    logger.info(f"[DRY-RUN] Would remove datapacks root {dp_root}")
                else:
                    shutil.rmtree(dp_root, ignore_errors=True)
        elif drivers:
            common = os.path.join(dest_root, COMMON_FOLDER)
            sync_folders(src, common, algorithm, copy_all=copy_all, logger=logger, dry_run=dry_run)
            for name in drivers:
                dpath = os.path.join(dest_root, DRIVERS_ROOT, name)
                copy_missing_files(src, dpath, copy_all, logger, dry_run=dry_run)
        else:
            sync_folders(src, dest_root, algorithm, copy_all=copy_all, logger=logger, dry_run=dry_run)

# inject implementation into globals for compatibility above
globals()["sync_team_folders_impl"] = sync_team_folders_impl

# Now implement perform_sync final steps using implemented functions
def perform_sync(ir_folder: str, cfg: dict, logger: Logger, dry_run: bool = False):
    src_name = cfg.get("sync_source")
    dst_name = cfg.get("sync_destination")
    if not src_name or not dst_name:
        logger.info("Sync source or destination not configured, skipping")
        return

    # Garage61 fetch
    if cfg.get("use_garage61") and cfg.get("garage61_team_id"):
        names = fetch_garage61_drivers(cfg.get("garage61_team_id"), cfg.get("garage61_api_key"), logger)
        if names is not None:
            cfg["drivers"] = [clean_name(n) for n in names if n]
            save_config(cfg)

    # external merge
    if cfg.get("use_external") and cfg.get("extra_folders"):
        merge_external_into_source(ir_folder, cfg["extra_folders"], src_name, dst_name, cfg["hash_algorithm"], cfg.get("copy_all", False), drivers=( [clean_name(n) for n in cfg.get("drivers", [])] if cfg.get("use_driver_folders") else None), driver_style=cfg.get("use_driver_folders", False), logger=logger, dry_run=dry_run)

    drivers = ( [clean_name(n) for n in cfg.get("drivers", [])] if cfg.get("use_driver_folders") else None)
    if drivers is not None:
        remove_unknown_driver_folders(ir_folder, dst_name, drivers, logger, dry_run=dry_run)

    sync_nascar_source_folders(ir_folder, src_name, cfg["hash_algorithm"], drivers=drivers, driver_style=cfg.get("use_driver_folders", False), logger=logger, dry_run=dry_run)
    sync_team_folders_impl(ir_folder, src_name, dst_name, cfg["hash_algorithm"], cfg.get("copy_all", False), drivers, cfg.get("use_driver_folders", False), logger, dry_run=dry_run)
    if not cfg.get("use_driver_folders"):
        sync_data_pack_folders = globals().get("sync_data_pack_folders_impl")
        if not sync_data_pack_folders:
            # define simple sync_data_pack_folders if missing
            def sync_data_pack_folders_impl(iracing_folder, src_team, dest_team, algorithm, copy_all, logger, dry_run=False):
                src_dp = os.path.join(src_team, "Data packs")
                dest_dp = os.path.join(dest_team, "Data packs")
                sync_group_folders(iracing_folder, src_dp, dest_dp, algorithm, copy_all, logger, dry_run=dry_run)
                sync_team_folders_impl(iracing_folder, src_dp, dest_dp, algorithm, copy_all, None, False, logger, dry_run=dry_run)
            globals()["sync_data_pack_folders_impl"] = sync_data_pack_folders_impl
            sync_data_pack_folders_impl(ir_folder, src_name, dst_name, cfg["hash_algorithm"], cfg.get("copy_all", False), logger, dry_run=dry_run)
        else:
            sync_data_pack_folders_impl(ir_folder, src_name, dst_name, cfg["hash_algorithm"], cfg.get("copy_all", False), logger, dry_run=dry_run)

# -------------------------
# Silent runner and tray
# -------------------------
def run_silent(cfg: dict, logger: Optional[Logger] = None, ask: bool = False, dry_run: bool = False):
    if logger is None:
        logger = Logger(cfg)
    logger.info("Running silent sync")
    ir_folder = cfg.get("iracing_folder")
    if not ir_folder or not os.path.exists(ir_folder):
        logger.error("Invalid or missing iRacing folder")
        return
    if cfg.get("backup_enabled") and cfg.get("backup_before_folder"):
        backup_iracing_folder(ir_folder, cfg["backup_before_folder"], cfg.get("copy_all", False), logger, dry_run=dry_run)
    if cfg.get("source_type") == "zip":
        z = cfg.get("zip_file")
        if z and os.path.exists(z):
            process_archive(z, cfg, logger, ask=ask, dry_run=dry_run)
        else:
            logger.info("Archive file not found, skipping import")
    elif cfg.get("source_type") == "folder":
        sf = cfg.get("source_folder")
        if sf and os.path.exists(sf):
            copy_from_source(sf, ir_folder, cfg, logger, ask=ask, dry_run=dry_run)
        else:
            logger.info("Source folder not found, skipping import")
    perform_sync(ir_folder, cfg, logger, dry_run=dry_run)
    if cfg.get("backup_enabled") and cfg.get("backup_after_folder"):
        backup_iracing_folder(ir_folder, cfg["backup_after_folder"], cfg.get("copy_all", False), logger, dry_run=dry_run)
    logger.info("Silent sync complete")

def run_tray(cfg: dict):
    if not PYSIDE6_AVAILABLE:
        print("PySide6 not available; cannot run tray UI. Running silent instead.")
        run_silent(cfg)
        return
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication(sys.argv)
    class TrayApp(QtWidgets.QWidget):
        def __init__(self, cfg):
            super().__init__()
            self.cfg = cfg
            self.setWindowTitle("Nishizumi Sync Tray")
    win = TrayApp(cfg)
    win.hide()
    icon_path = os.path.join(BASE_DIR, "icon.png")
    icon = QtGui.QIcon(icon_path) if os.path.exists(icon_path) else app.windowIcon()
    tray = QtWidgets.QSystemTrayIcon(icon)
    menu = QtWidgets.QMenu()
    act_run = menu.addAction("Run now")
    act_quit = menu.addAction("Quit")
    act_run.triggered.connect(lambda: run_silent(cfg))
    act_quit.triggered.connect(app.quit)
    tray.setContextMenu(menu)
    tray.show()
    timer = QtCore.QTimer()
    timer.timeout.connect(lambda: run_silent(cfg))
    timer.start(max(1, int(cfg.get("tray_interval", 2))) * 3600 * 1000)
    run_silent(cfg)
    app.exec()

# -------------------------
# GUI: Full MainWindow
# -------------------------
class MainWindow(QtWidgets.QWidget if PYSIDE6_AVAILABLE else object):
    def __init__(self, cfg: dict):
        if not PYSIDE6_AVAILABLE:
            raise RuntimeError("PySide6 not available")
        super().__init__()
        self.cfg = cfg
        self.logger = Logger(cfg)
        self.setWindowTitle("Nishizumi Setups Sync — Full")
        self.resize(820, 820)
        self._build_ui()
    def _build_ui(self):
        layout = QtWidgets.QVBoxLayout(self)
        instr = QtWidgets.QLabel("Fill options then press Save or Run. Missing folders are created automatically.")
        instr.setWordWrap(True)
        layout.addWidget(instr)
        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        layout.addWidget(scroll)
        content = QtWidgets.QWidget()
        scroll.setWidget(content)
        form = QtWidgets.QFormLayout(content)
        # iRacing folder
        self.ir_entry = QtWidgets.QLineEdit(self.cfg.get("iracing_folder", ""))
        btn_ir = QtWidgets.QPushButton("Browse")
        def browse_ir():
            p = QtWidgets.QFileDialog.getExistingDirectory(self, "Select iRacing Setups Folder")
            if p:
                self.ir_entry.setText(p)
        btn_ir.clicked.connect(browse_ir)
        w = QtWidgets.QWidget()
        h = QtWidgets.QHBoxLayout(w); h.setContentsMargins(0,0,0,0)
        h.addWidget(self.ir_entry); h.addWidget(btn_ir)
        form.addRow("iRacing Setups Folder:", w)
        # source selection
        self.src_type = QtWidgets.QComboBox()
        self.src_type.addItems(["zip", "folder", "none"])
        self.src_type.setCurrentText(self.cfg.get("source_type","zip"))
        form.addRow("Import Mode:", self.src_type)
        # zip entry
        self.zip_entry = QtWidgets.QLineEdit(self.cfg.get("zip_file",""))
        btn_zip = QtWidgets.QPushButton("Browse")
        def browse_zip():
            path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select Archive", filter="ZIP or RAR (*.zip *.rar)")
            if path:
                self.zip_entry.setText(path)
        btn_zip.clicked.connect(browse_zip)
        wzip = QtWidgets.QWidget(); hzip = QtWidgets.QHBoxLayout(wzip); hzip.setContentsMargins(0,0,0,0)
        hzip.addWidget(self.zip_entry); hzip.addWidget(btn_zip)
        form.addRow("Archive to import:", wzip)
        # source folder
        self.src_entry = QtWidgets.QLineEdit(self.cfg.get("source_folder",""))
        btn_src = QtWidgets.QPushButton("Browse")
        def browse_src():
            p = QtWidgets.QFileDialog.getExistingDirectory(self, "Select Source Folder")
            if p:
                self.src_entry.setText(p)
        btn_src.clicked.connect(browse_src)
        wsrc = QtWidgets.QWidget(); hsrc = QtWidgets.QHBoxLayout(wsrc); hsrc.setContentsMargins(0,0,0,0)
        hsrc.addWidget(self.src_entry); hsrc.addWidget(btn_src)
        form.addRow("Folder to import:", wsrc)
        # team/personal/supplier/season
        self.team_entry = QtWidgets.QLineEdit(self.cfg.get("team_folder",""))
        self.personal_entry = QtWidgets.QLineEdit(self.cfg.get("personal_folder",""))
        self.supplier_entry = QtWidgets.QLineEdit(self.cfg.get("supplier_folder",""))
        self.season_entry = QtWidgets.QLineEdit(self.cfg.get("season_folder",""))
        form.addRow("Team Folder Name:", self.team_entry)
        form.addRow("Personal Folder Name:", self.personal_entry)
        form.addRow("Supplier/Driver Folder:", self.supplier_entry)
        form.addRow("Season Folder:", self.season_entry)
        # sync source/dest
        self.sync_src = QtWidgets.QLineEdit(self.cfg.get("sync_source",""))
        self.sync_dst = QtWidgets.QLineEdit(self.cfg.get("sync_destination",""))
        form.addRow("Sync Source (copy from):", self.sync_src)
        form.addRow("Sync Destination (copy to):", self.sync_dst)
        # extra folders
        self.use_extra = QtWidgets.QCheckBox("Use extra sync folders")
        self.use_extra.setChecked(self.cfg.get("use_external", False))
        form.addRow(self.use_extra)
        self.extra_list = QtWidgets.QListWidget()
        for ef in self.cfg.get("extra_folders", []):
            it = QtWidgets.QListWidgetItem(f"{ef.get('name')} ({ef.get('location')})")
            it.setData(QtCore.Qt.UserRole, ef)
            self.extra_list.addItem(it)
        btn_add_extra = QtWidgets.QPushButton("Add Extra Folder")
        def add_extra():
            dlg = QtWidgets.QInputDialog(self)
            name, ok = dlg.getText(self, "Extra Folder", "Folder name (inside car or dest):")
            if ok and name.strip():
                loc, ok2 = QtWidgets.QInputDialog.getItem(self, "Location", "Location:", ["car","dest"], 0, False)
                if ok2:
                    ef = {"name": clean_name(name.strip()), "location": loc}
                    it = QtWidgets.QListWidgetItem(f"{ef['name']} ({ef['location']})")
                    it.setData(QtCore.Qt.UserRole, ef)
                    self.extra_list.addItem(it)
        btn_rm_extra = QtWidgets.QPushButton("Remove Selected Extra")
        def rm_extra():
            for it in self.extra_list.selectedItems():
                self.extra_list.takeItem(self.extra_list.row(it))
        btn_add_extra.clicked.connect(add_extra)
        btn_rm_extra.clicked.connect(rm_extra)
        he = QtWidgets.QHBoxLayout(); he.addWidget(btn_add_extra); he.addWidget(btn_rm_extra)
        form.addRow(self.extra_list); form.addRow(QtWidgets.QWidget(), None); form.addRow(QtWidgets.QLabel("Extras controls:"), None)
        form.addRow("", QtWidgets.QWidget())
        form.addRow("", QtWidgets.QWidget())
        # hashing and copy all
        self.algo = QtWidgets.QComboBox(); self.algo.addItems(["md5","sha256"]); self.algo.setCurrentText(self.cfg.get("hash_algorithm","md5"))
        self.copy_all = QtWidgets.QCheckBox("Copy everything (not just .sto)")
        self.copy_all.setChecked(self.cfg.get("copy_all", False))
        form.addRow("Hash Algorithm:", self.algo)
        form.addRow(self.copy_all)
        # backup
        self.backup_check = QtWidgets.QCheckBox("Enable backup")
        self.backup_check.setChecked(self.cfg.get("backup_enabled", False))
        self.back_before = QtWidgets.QLineEdit(self.cfg.get("backup_before_folder",""))
        btn_before = QtWidgets.QPushButton("Browse")
        btn_before.clicked.connect(lambda: self._browse_set(self.back_before, "Select Backup (before)"))
        self.back_after = QtWidgets.QLineEdit(self.cfg.get("backup_after_folder",""))
        btn_after = QtWidgets.QPushButton("Browse")
        btn_after.clicked.connect(lambda: self._browse_set(self.back_after, "Select Backup (after)"))
        wback1 = QtWidgets.QWidget(); hb1 = QtWidgets.QHBoxLayout(wback1); hb1.setContentsMargins(0,0,0,0); hb1.addWidget(self.back_before); hb1.addWidget(btn_before)
        wback2 = QtWidgets.QWidget(); hb2 = QtWidgets.QHBoxLayout(wback2); hb2.setContentsMargins(0,0,0,0); hb2.addWidget(self.back_after); hb2.addWidget(btn_after)
        form.addRow(self.backup_check); form.addRow("Backup (before):", wback1); form.addRow("Backup (after):", wback2)
        # logging
        self.log_check = QtWidgets.QCheckBox("Enable logging to file")
        self.log_check.setChecked(self.cfg.get("enable_logging", False))
        self.log_file = QtWidgets.QLineEdit(self.cfg.get("log_file",""))
        btn_log = QtWidgets.QPushButton("Browse")
        btn_log.clicked.connect(lambda: self._browse_set(self.log_file, "Select log file", file=True))
        wlog = QtWidgets.QWidget(); hlog = QtWidgets.QHBoxLayout(wlog); hlog.setContentsMargins(0,0,0,0); hlog.addWidget(self.log_file); hlog.addWidget(btn_log)
        form.addRow(self.log_check); form.addRow("Log file:", wlog)
        # driver folders
        drivers_group = QtWidgets.QGroupBox("Driver folders")
        dg = QtWidgets.QVBoxLayout(drivers_group)
        self.garage_check = QtWidgets.QCheckBox("Use Garage61 API for drivers")
        self.garage_check.setChecked(self.cfg.get("use_garage61", False))
        self.team_id = QtWidgets.QLineEdit(self.cfg.get("garage61_team_id",""))
        self.api_key = QtWidgets.QLineEdit(self.cfg.get("garage61_api_key",""))
        self.api_key.setEchoMode(QtWidgets.QLineEdit.Password)
        self.manual_drivers_check = QtWidgets.QCheckBox("Manually enter drivers")
        self.manual_drivers_check.setChecked(self.cfg.get("use_driver_folders", False))
        dg.addWidget(self.garage_check); dg.addRow = dg.addWidget
        dg.addWidget(QtWidgets.QLabel("Garage61 Team ID:")); dg.addWidget(self.team_id)
        dg.addWidget(QtWidgets.QLabel("Garage61 API Key:")); dg.addWidget(self.api_key)
        dg.addWidget(self.manual_drivers_check)
        self.driver_list = QtWidgets.QListWidget()
        for d in self.cfg.get("drivers", []):
            it = QtWidgets.QListWidgetItem(d)
            it.setData(QtCore.Qt.UserRole, d)
            self.driver_list.addItem(it)

        btn_add_driver = QtWidgets.QPushButton("Add Driver")
        btn_remove_driver = QtWidgets.QPushButton("Remove Selected")

        def add_driver():
            dlg = QtWidgets.QInputDialog(self)
            name, ok = dlg.getText(self, "Add Driver", "Driver name:")
            if ok and name.strip():
                name = clean_name(name.strip())
                it = QtWidgets.QListWidgetItem(name)
                it.setData(QtCore.Qt.UserRole, name)
                self.driver_list.addItem(it)

        def rm_driver():
            for it in self.driver_list.selectedItems():
                self.driver_list.takeItem(self.driver_list.row(it))

        btn_add_driver.clicked.connect(add_driver)
        btn_remove_driver.clicked.connect(rm_driver)

        dbuttons = QtWidgets.QHBoxLayout()
        dbuttons.addWidget(btn_add_driver)
        dbuttons.addWidget(btn_remove_driver)

        dg.addWidget(self.driver_list)
        dg.addLayout(dbuttons)

        # Enable/disable driver fields depending on Garage61 toggles
        def update_driver_mode():
            use_api = self.garage_check.isChecked()
            manual = self.manual_drivers_check.isChecked()
            self.team_id.setEnabled(use_api)
            self.api_key.setEnabled(use_api)
            self.driver_list.setEnabled(manual)
            btn_add_driver.setEnabled(manual)
            btn_remove_driver.setEnabled(manual)

        self.garage_check.toggled.connect(update_driver_mode)
        self.manual_drivers_check.toggled.connect(update_driver_mode)
        update_driver_mode()

        form.addRow(drivers_group)

        # Start-up & tray mode
        self.startup_check = QtWidgets.QCheckBox("Run silently on startup")
        self.startup_check.setChecked(self.cfg.get("run_on_startup", False))

        self.tray_check = QtWidgets.QCheckBox("Stay in tray and rescan periodically")
        self.tray_check.setChecked(self.cfg.get("tray_mode", False))
        self.tray_interval = QtWidgets.QSpinBox()
        self.tray_interval.setRange(1, 24)
        self.tray_interval.setValue(self.cfg.get("tray_interval", 2))

        th = QtWidgets.QHBoxLayout()
        th.addWidget(self.tray_check)
        th.addWidget(QtWidgets.QLabel("Every"))
        th.addWidget(self.tray_interval)
        th.addWidget(QtWidgets.QLabel("hours"))

        form.addRow(self.startup_check)
        form.addRow(th)

        # Buttons
        buttons = QtWidgets.QHBoxLayout()
        btn_save = QtWidgets.QPushButton("Save Config")
        btn_run = QtWidgets.QPushButton("Run Now")
        btn_update = QtWidgets.QPushButton("Check for Updates")

        buttons.addWidget(btn_save)
        buttons.addWidget(btn_run)
        buttons.addWidget(btn_update)

        form.addRow(buttons)

        # Button actions
        btn_save.clicked.connect(self.save_only)
        btn_run.clicked.connect(self.save_and_run)
        btn_update.clicked.connect(lambda: apply_update(self.logger))

    # Helpers
    def _browse_set(self, widget, title, file=False):
        if file:
            path, _ = QtWidgets.QFileDialog.getOpenFileName(self, title)
        else:
            path = QtWidgets.QFileDialog.getExistingDirectory(self, title)
        if path:
            widget.setText(path)

    def collect_config(self) -> dict:
        cfg = dict(self.cfg)

        cfg["iracing_folder"] = self.ir_entry.text().strip()
        cfg["source_type"] = self.src_type.currentText()
        cfg["zip_file"] = self.zip_entry.text().strip()
        cfg["source_folder"] = self.src_entry.text().strip()
        cfg["team_folder"] = clean_name(self.team_entry.text())
        cfg["personal_folder"] = clean_name(self.personal_entry.text())
        cfg["supplier_folder"] = clean_name(self.supplier_entry.text())
        cfg["season_folder"] = clean_name(self.season_entry.text())
        cfg["sync_source"] = clean_name(self.sync_src.text())
        cfg["sync_destination"] = clean_name(self.sync_dst.text())

        cfg["hash_algorithm"] = self.algo.currentText()
        cfg["copy_all"] = self.copy_all.isChecked()

        # Backup
        cfg["backup_enabled"] = self.backup_check.isChecked()
        cfg["backup_before_folder"] = self.back_before.text().strip()
        cfg["backup_after_folder"] = self.back_after.text().strip()

        # Logging
        cfg["enable_logging"] = self.log_check.isChecked()
        cfg["log_file"] = self.log_file.text().strip()

        # Extra folders
        extras = []
        for i in range(self.extra_list.count()):
            data = self.extra_list.item(i).data(QtCore.Qt.UserRole)
            if isinstance(data, dict):
                extras.append({
                    "name": clean_name(data.get("name")),
                    "location": data.get("location", "car"),
                })
        cfg["extra_folders"] = extras
        cfg["use_external"] = self.use_extra.isChecked()

        # Drivers
        cfg["use_garage61"] = self.garage_check.isChecked()
        cfg["garage61_team_id"] = self.team_id.text().strip()
        cfg["garage61_api_key"] = self.api_key.text().strip()
        cfg["use_driver_folders"] = self.manual_drivers_check.isChecked()

        drivers = []
        for i in range(self.driver_list.count()):
            d = self.driver_list.item(i).data(QtCore.Qt.UserRole)
            if d:
                drivers.append(clean_name(d))
        cfg["drivers"] = drivers

        # Tray / startup
        cfg["run_on_startup"] = self.startup_check.isChecked()
        cfg["tray_mode"] = self.tray_check.isChecked()
        cfg["tray_interval"] = self.tray_interval.value()

        return cfg

    def save_only(self):
        cfg = self.collect_config()
        save_config(cfg)
        QtWidgets.QMessageBox.information(self, "Saved", "Configuration saved successfully")

    def save_and_run(self):
        cfg = self.collect_config()
        save_config(cfg)
        run_silent(cfg, self.logger, ask=True)
        QtWidgets.QMessageBox.information(self, "Done", "Sync completed")

# -------------------------
# GUI END — now CLI
# -------------------------

def build_argparser():
    parser = argparse.ArgumentParser(
        prog="NishizumiSetupsSync",
        description="Sync iRacing setups between team/personal/supplier folders with optional import and GUI."
    )

    sub = parser.add_subparsers(dest="cmd")

    # --- run ---
    run = sub.add_parser("run", help="Run sync (silent)")
    run.set_defaults(cmd="run")
    run.add_argument("--dry-run", action="store_true", help="Simulate all operations")

    # --- import ---
    imp = sub.add_parser("import", help="Import an archive or folder")
    imp.set_defaults(cmd="import")
    imp.add_argument("path", help="ZIP, RAR, or folder to import")

    # --- check-update ---
    cu = sub.add_parser("check-update", help="Check for updates")
    cu.set_defaults(cmd="check-update")

    # --- update ---
    up = sub.add_parser("update", help="Apply update if available")
    up.set_defaults(cmd="update")

    # --- dry-run ---
    dr = sub.add_parser("dry-run", help="Run sync in full simulation mode")
    dr.set_defaults(cmd="dry-run")

    # --- gui ---
    gui = sub.add_parser("gui", help="Launch full GUI")
    gui.set_defaults(cmd="gui")

    return parser
def main(argv=None):
    cfg = load_config()
    logger = Logger(cfg)

    parser = build_argparser()
    args = parser.parse_args(argv)

    # Default behavior: open GUI if PySide6 available
    if args.cmd is None:
        if PYSIDE6_AVAILABLE:
            args.cmd = "gui"
        else:
            args.cmd = "run"

    # -------------------
    # DISPATCH
    # -------------------
    if args.cmd == "gui":
        if not PYSIDE6_AVAILABLE:
            logger.error("PySide6 not installed. Cannot open GUI.")
            return
        app = QtWidgets.QApplication.instance() or QtWidgets.QApplication(sys.argv)
        win = MainWindow(cfg)
        win.show()
        app.exec()
        return

    if args.cmd == "run":
        run_silent(cfg, logger, dry_run=getattr(args, "dry_run", False))
        return

    if args.cmd == "dry-run":
        run_silent(cfg, logger, dry_run=True)
        return

    if args.cmd == "import":
        path = args.path
        if not os.path.exists(path):
            logger.error(f"Import path not found: {path}")
            return
        if os.path.isfile(path):
            process_archive(path, cfg, logger, ask=True)
        else:
            copy_from_source(path, cfg["iracing_folder"], cfg, logger, ask=True)
        return

    if args.cmd == "check-update":
        remote, _ = check_for_update(logger)
        if remote:
            print(f"Update available: {remote}")
        else:
            print("No update available.")
        return

    if args.cmd == "update":
        apply_update(logger)
        return
if __name__ == "__main__":
    main(sys.argv[1:])

